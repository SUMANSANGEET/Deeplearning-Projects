# -*- coding: utf-8 -*-
"""Creating an ANN Model in Python and Calculating Metrics from Scratch.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1LCqw_LZWfETz87W3hAkWNplEf9ViotCI
"""

import numpy as np
import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import LabelBinarizer
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense

# Step 1: Generate Dummy Data
np.random.seed(42)
X = np.random.rand(1000, 10)  # 1000 samples, 10 features
y = np.random.randint(0, 2, size=1000)  # Binary classification (0 or 1)

# Step 2: Train/Test Split
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Step 3: Build ANN Model
model = Sequential([
    Dense(32, activation='relu', input_shape=(X_train.shape[1],)),
    Dense(16, activation='relu'),
    Dense(1, activation='sigmoid')  # Sigmoid for binary classification
])

model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])

# Step 4: Train the Model
model.fit(X_train, y_train, epochs=10, batch_size=32, validation_data=(X_test, y_test), verbose=0)

# Step 5: Generate Predictions
proba = model.predict(X_test).flatten()  # Probabilities
predictions = (proba > 0.5).astype(int)  # Threshold at 0.5 for binary classification
max_proba = np.max(proba)  # For example purposes, showing the max probability

# Step 6: Create DataFrame
df = pd.DataFrame({
    'Max_proba': proba,
    'Index': np.arange(len(proba)),
    'Prediction_class': predictions,
    'Ground_Truth_class': y_test,
    'Output': np.where(predictions == y_test, 'Correct', 'Incorrect')  # Compare predictions
})

# Step 7: Calculate Metrics
# True Positives, False Positives, True Negatives, False Negatives
TP = np.sum((predictions == 1) & (y_test == 1))
FP = np.sum((predictions == 1) & (y_test == 0))
TN = np.sum((predictions == 0) & (y_test == 0))
FN = np.sum((predictions == 0) & (y_test == 1))

# Accuracy
accuracy = (TP + TN) / len(y_test)

# Precision
precision = TP / (TP + FP) if (TP + FP) > 0 else 0

# Recall
recall = TP / (TP + FN) if (TP + FN) > 0 else 0

# F1-Score
f1_score = 2 * (precision * recall) / (precision + recall) if (precision + recall) > 0 else 0

# Print Results
print("Accuracy:", accuracy)
print("Precision:", precision)
print("Recall:", recall)
print("F1-Score:", f1_score)

# Display DataFrame
print(df.head())

"""**1. Import Necessary Libraries:**"""

import numpy as np
import pandas as pd
import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense
from tensorflow.keras.datasets import mnist
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import LabelBinarizer
from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score

"""**2. Load and Preprocess the Data:**"""

np.random.seed(42)
X = np.random.rand(1000, 10)  # 1000 samples, 10 features
y = np.random.randint(0, 2, size=1000)  # Binary classification (0 or 1)

"""**3.Train/Test Split:**"""

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

"""**4.Build the ANN model**"""

model = Sequential([
    Dense(32, activation='relu', input_shape=(X_train.shape[1],)),
    Dense(16, activation='relu'),
    Dense(1, activation='sigmoid')  # Sigmoid for binary classification
])

model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])

"""4. **Train the Model:**"""

model.fit(X_train, y_train, epochs=10, batch_size=32, validation_data=(X_test, y_test), verbose=0)

"""**5. Make Predictions:**"""

proba = model.predict(X_test).flatten()  # Probabilities
predictions = (proba > 0.5).astype(int)  # Threshold at 0.5 for binary classification
max_proba = np.max(proba)  # For example purposes, showing the max probability

"""**6.Create Dataframe**"""

df = pd.DataFrame({
    'Max_proba': proba,
    'Index': np.arange(len(proba)),
    'Prediction_class': predictions,
    'Ground_Truth_class': y_test,
    'Output': np.where(predictions == y_test, 'Correct', 'Incorrect')  # Compare predictions
})

"""**6.Calculate Metrics**"""

# True Positives, False Positives, True Negatives, False Negatives
TP = np.sum((predictions == 1) & (y_test == 1))
FP = np.sum((predictions == 1) & (y_test == 0))
TN = np.sum((predictions == 0) & (y_test == 0))
FN = np.sum((predictions == 0) & (y_test == 1))
# Accuracy
accuracy = (TP + TN) / len(y_test)

# Precision
precision = TP / (TP + FP) if (TP + FP) > 0 else 0

# Recall
recall = TP / (TP + FN) if (TP + FN) > 0 else 0

# F1-Score
f1_score = 2 * (precision * recall) / (precision + recall) if (precision + recall) > 0 else 0

"""**7.Print Results:**"""

print("Accuracy:", accuracy)
print("Precision:", precision)
print("Recall:", recall)
print("F1-Score:", f1_score)

"""**Display Dataframe**"""

print(df.head())